#!/usr/bin/env python3
"""
gen_sphere.py

Generate UV sphere vertex/normal/index arrays and print C++-ready constexpr std::array.
- Sphere radius = 1.0 (unit sphere)
- Configurable segments (latitudes and longitudes)
- Smooth normals (normalized position vectors)
"""

from typing import List, Tuple
import math

# Sphere parameters
LAT_SEGMENTS = 16*8  # latitude divisions (from top to bottom, excluding poles)
LON_SEGMENTS = 32*8  # longitude divisions (around equator)
RADIUS = 1.0

Vec3 = Tuple[float, float, float]

# Helpers
def fmt_f(f: float) -> str:
    s = f"{f:.6f}"
    if '.' in s:
        s = s.rstrip('0').rstrip('.')
        if '.' not in s:
            s += '.0'
    return s + 'f'

def cpp_array_floats(name: str, arr: List[float], per_line: int = 6) -> str:
    out = [f"constexpr std::array<float, {len(arr)}> {name} = {{"]
    line = "    "
    for i, v in enumerate(arr):
        line += fmt_f(v) + ", "
        if (i+1) % per_line == 0:
            out.append(line)
            line = "    "
    if line.strip(): out.append(line)
    out.append("};")
    return "\n".join(out)

def cpp_array_uints(name: str, arr: List[int], per_line: int = 12) -> str:
    out = [f"constexpr std::array<unsigned int, {len(arr)}> {name} = {{"]
    line = "    "
    for i, v in enumerate(arr):
        line += str(v) + ", "
        if (i+1) % per_line == 0:
            out.append(line)
            line = "    "
    if line.strip(): out.append(line)
    out.append("};")
    return "\n".join(out)

# Generate vertices
vertices: List[Vec3] = []
normals: List[Vec3] = []

for i in range(LAT_SEGMENTS + 1):
    theta = math.pi * i / LAT_SEGMENTS  # 0->pi
    sin_theta = math.sin(theta)
    cos_theta = math.cos(theta)

    for j in range(LON_SEGMENTS + 1):
        phi = 2 * math.pi * j / LON_SEGMENTS  # 0->2pi
        sin_phi = math.sin(phi)
        cos_phi = math.cos(phi)

        x = sin_theta * cos_phi
        y = cos_theta
        z = sin_theta * sin_phi

        pos = (RADIUS * x, RADIUS * y, RADIUS * z)
        vertices.append(pos)
        normals.append((x, y, z))  # unit sphere, normals = positions

# Flatten vertices to interleaved pos+normal array
flat_vertices: List[float] = []
for (x,y,z), (nx,ny,nz) in zip(vertices, normals):
    flat_vertices.extend([x,y,z,nx,ny,nz])

# Generate indices (triangles)
indices: List[int] = []
for i in range(LAT_SEGMENTS):
    for j in range(LON_SEGMENTS):
        a = i * (LON_SEGMENTS + 1) + j
        b = a + LON_SEGMENTS + 1
        c = a + 1
        d = b + 1

        if i != 0:
            indices.extend([a, c, b])  # upper triangle - CCW 
        if i != LAT_SEGMENTS - 1:
            indices.extend([c, d, b])  # lower triangle - CCW

# Print C++ arrays
print("#pragma once")
print()
print("#include <array>")
print()
print("// Generated by gen_sphere.py")
print(cpp_array_floats("sphereVertices", flat_vertices, per_line=6))
print()
print(cpp_array_uints("sphereIndices", indices, per_line=12))
print()
print("// Aliases for stable names (so both generators provide the same symbols)")
print("constexpr auto cubeVertices = sphereVertices;")
print("constexpr auto cubeIndices = sphereIndices;")
print()
print(f"// Vertex count: {len(vertices)}")
print(f"// Index count : {len(indices)}")
